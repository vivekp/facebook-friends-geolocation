
var geocoder;				//global variable to create Maps API Instance
var names = new Array();		//store the names we got from server
var locations = new Array();		//store the locations we got from server
var lats = new Array();			//store the lat-lon address for the corresponding locations
var distance_matrix = new Array();	//store the distance between lats[i] and lats[j]
var lat_long = null;			//global variable to hold the lat_long value temporarily
var permFriends = new Array();		//global variable to hold all the permutation of friends
var msg;				//to add messages to an elememnt in the page
var mstOrder;				/*global variable to hold the order of visit generated by preorder
					 *traversal on Minimum spanning tree of the locations.
					 */
					 
function bootstrap(flag) {
	var msg = document.getElementById("message").innerHTML;

	getUserLocations();
	
	geocoder = new GClientGeocoder();

	var len = locations.length;


	var flags = new Array(len);
	for(var i = 0 ; i < len ; i++) {
		var address = locations[i];
		flags[i] = false;
		findLocation(address, i, flags);
	}

	// TO DO: Design a way to wait for asynchronous Maps API calls to complete.
	
	if(flag) {	// Do this when user actually clicks the button to schedule the visit.
		if(locations.length > 1) {	// Do this only if user has any friend.	
			generateDistanceMatrix();
			/*
			 * Solve the Euclidean TSP problem assuming cities are points in a plane
			 * which follow the triangle inequality law.
			 */
			findVisitOrder();		
		}
	}
}

function getUserLocations() {
	var el = document.getElementById("locations");

	var counter = 0 ;
	//Get the name and location of user.
	var source_name = el.children[0].innerHTML;
	var source_location = el.children[1].innerHTML;
	names[counter] = source_name;
	locations[counter] = source_location;
	counter++;

	//Get the name and location of friends.
	var tableEl = el.children[3];
	var trEl = tableEl.children[0].children;
	var len = trEl.length;

	for (var i = 0 ; i < len ; i++) {
		var tdEl = trEl[i].children;
		var len2 = tdEl.length;
		for (var j = 0 ; j < len2 ; j += 2 ) {
			var div = tdEl[j].children;
			div = div[0];
			var attr = div.attributes;
			var id = attr[0].value;

			if( id == ("name"+counter) ) {
				names[counter] = div.innerHTML;
			} else if( id == ("location"+counter) ) {
				locations[counter] = div.innerHTML;
			}
		}
		counter++;
	}
}

function calculateDistance(src, dst) {
	try
	{
		var glatlng1 = new GLatLng(src.lat, src.lon);
		var glatlng2 = new GLatLng(dst.lat, dst.lon);
		var miledistance = glatlng1.distanceFrom(glatlng2, 3959).toFixed(1);
		var kmdistance = (miledistance * 1.609344).toFixed(1);
		return kmdistance;
	}
	catch (error)
	{
		alert(error);
	}
	return -1;
}

function findLocation(address, index, flags) {
	geocoder.getLocations(address, function (response) {
		if (response.Status.code != 200)
		{
			alert("Sorry, G Maps API is unable to geocode : " + address + "(" + names[index] + ")");
			document.getElementById("message").innerHTML = "<div style='color:red;'>Critical error encountered in geocoding the address. The result and state of the system is unknown from this point on. Please refresh the page and try again ! If the problem persists, blame Google Maps API, not me. ;) The map below shows the location of friends for which address could be geocoded. </div>";
			lats[index] = null;
			return -1;
		}
		else
		{
			lat_long = {lat: response.Placemark[0].Point.coordinates[1], lon: response.Placemark[0].Point.coordinates[0], address: response.Placemark[0].address};
			lats[index] = lat_long;
			flags[index] = true;
		}	
	});
}

function generateDistanceMatrix() {
	document.getElementById("message").innerHTML += "generating distance matrix... <br/>";
	var len = lats.length;

	for(var i = 0 ; i < len ; i++) {
		distance_matrix[i] = new Array(len);
	}

 	for(var i = 0 ; i < len ; i++) {
		if(lats[i] == null) continue;
		
		for(var j = i+1 ; j < len ; j++) {
			if(lats[j] == null) continue;
			if(lats[i] != null && lats[j] != null) {
				distance_matrix[i][j] = calculateDistance(lats[i], lats[j]);
				distance_matrix[j][i] = distance_matrix[i][j];	
			}
		}	
	}
}

function initialize_map() {
	var latlng = new google.maps.LatLng(22.71539,78.530273);
	var myOptions = {
		zoom: 4,
		center: latlng,
		mapTypeId: google.maps.MapTypeId.ROADMAP
	};
	var map = new google.maps.Map(document.getElementById("map_canvas"), myOptions);
	var len = lats.length;
	for(var i = 0 ; i < len ; i++) {
	   if(lats[i] != null) {
		var latlng = new google.maps.LatLng(lats[i].lat, lats[i].lon);
		var marker = new google.maps.Marker({
      				position: latlng, 
   				map: map, 
		        	title:names[i] + " | " + lats[i].address
  		});   
	   }
	}
}

function findVisitOrder() {
	document.getElementById("message").innerHTML += "finding friends visit order for you... <br/>";

	/* if no. of friends is less than 6, simply find all the permutations. */
	var num = lats.length - 1; 	// num is the no. of friends.
	getPermFromStore(num);			
	if(permFriends == null) {
		if(!mst_prim())	{
			alert("Some error encountered in scheduling visit ! " );
			return false;
		}
	}

	var len = permFriends.length;
	var index = 0, distance = parseFloat('0');
	var path = locations[0];

	var i = 0;
	var visit_order = permFriends[i];

	distance = distance + parseFloat(distance_matrix[0][visit_order[0]]);	

	for(var j = 0 ; j <(num-1); j++) {
		distance = distance + parseFloat(distance_matrix[visit_order[j]][visit_order[j+1]]);	
		path.concat(" -> ", locations[visit_order[j]], " -> ", locations[visit_order[j+1]]);	
	}

	i++;	
	
	for( ; i < len ; i++) {
		var visit_order = permFriends[i];
		var temp_dist = parseFloat('0');
 
		temp_dist = temp_dist + parseFloat(distance_matrix[0][visit_order[0]]);	
		var temp_path = locations[0];

		for(var j = 0 ; j <(num-1); j++) {
			temp_dist = temp_dist + parseFloat(distance_matrix[visit_order[j]][visit_order[j+1]]);	
			temp_path.concat(" -> ", locations[visit_order[j]], " -> ", locations[visit_order[j+1]]);	
		}

		if(temp_dist < distance) {	
			distance = temp_dist;
			index = i;
			path = temp_path
		}
	}
	
	var final_visit_order = permFriends[index];
	document.getElementById("message").innerHTML += "<br><span class='blue'>You should plan your return trip in the following order:</span><br/>";
	document.getElementById("message").innerHTML += (locations[0] + " -> ");

	for(var v = 0 ; v < num; v++) {
		document.getElementById("message").innerHTML += (locations[final_visit_order[v]] + "(" + names[final_visit_order[v]] +") -> ");	
	}		
	document.getElementById("message").innerHTML += (locations[0] + "<br />"); 

	/*
	 * reach here only if we have less than 6 friends, and show that the result can also be 
	 * generated using MST and TSP using triangle enquality.	
	 */
	mst_prim();
}

function mst_prim()
{
	var len = lats.length;
	var key = new Array(len);	 	
	var q = new Array(len);
	var pi = new Array(len);
	var left = new Array(len);
	var right = new Array(len);
	
	for(var u = 0 ; u < len ; u++) {
		q[u] = u;
		key[u] = parseFloat("999999999999999");
		pi[u] = -1;	
		left[u] = -1;
		right[u] = -1;
	} 

	key[0] = parseFloat("0");

	while(q.length > 0) {
		// Extract minimum from Q
		var qsize = q.length;
		var temp = parseFloat("999999999999999");
		var index = 0;
		for(var j = 0 ; j < qsize ; j++) {
			if(key[q[j]] < temp) {
				temp = key[q[j]];
				index = j;
			}
		}
		var value = q[index];
		q.splice(index, 1);			
		var u = value;

		for(var v = 0 ; v < len ; v++) {
			var flag = false;
			if(v != u ) {	// check if v is in Q  
				var qsize = q.length;
				for ( var j = 0 ; j < qsize ; j++) {
					if(v == q[j]) {
						flag = true;
						break;
					}	
				}
			}
			if(flag && parseFloat(distance_matrix[u][v]) < key[v]) {
				pi[v] = u;
				key[v] = parseFloat(distance_matrix[u][v]);
			}
		}
	}

	/*
	 * Construct left and right child using the parent information.
	 */
	for(var u = 1 ; u < len ; u++) {
		var p = pi[u];
		if(left[p] == -1) left[p] = u;
		else if(right[p] == -1) right[p] = u;
		else { 
			alert('Something went wrong while generating Minimum Spanning Tree. Results may not be correct. !');
			return false;
		}
	}

	// Do preorder traversal to generate approximate solution.
	document.getElementById("message").innerHTML += "<br/><span class='blue'>Vist order generated by using Minimum spanning tree based on friends locations and triangle inequality theorem: (Please note that this may not give the shortest path, but the result will be very close to the shortest path :) )</span><br/>";
	preorder(left, right, 0);		
	document.getElementById("message").innerHTML += locations[0] + "(" + names[0] + ") <br/><br/>";

	return true;
}

function preorder(left, right , node) {
	if(node == -1) return;
	document.getElementById("message").innerHTML += locations[node] + "(" + names[node] + ") -> ";
	preorder(left, right, left[node]);
	preorder(left, right, right[node]);	
}


function getPermFromStore(num) {
	var perm5 = ["12345","12354","12435","12453","12534","12543","13245","13254","13425","13452","13524","13542","14235","14253","14325","14352","14523","14532","15234","15243","15324","15342","15423","15432","21345","21354","21435","21453","21534","21543","23145","23154","23415","23451","23514","23541","24135","24153","24315","24351","24513","24531","25134","25143","25314","25341","25413","25431","31245","31254","31425","31452","31524","31542","32145","32154","32415","32451","32514","32541","34125","34152","34215","34251","34512","34521","35124","35142","35214","35241","35412","35421","41235","41253","41325","41352","41523","41532","42135","42153","42315","42351","42513","42531","43125","43152","43215","43251","43512","43521","45123","45132","45213","45231","45312","45321","51234","51243","51324","51342","51423","51432","52134","52143","52314","52341","52413","52431","53124","53142","53214","53241","53412","53421","54123","54132","54213","54231","54312","54321"];

	var perm4 = ["1234","1243","1324","1342","1423","1432","2134","2143","2314","2341","2413","2431","3124","3142","3214","3241","3412","3421","4123","4132","4213","4231","4312","4321"];

	var perm3 = ["123","132","213","231","312","321"];

	var perm2 = ["12","21"]; 

	var perm1 = ["1"];
	
	switch(num) {
		case 1:
			permFriends = perm1.slice(0);
			break;
		case 2:
			permFriends = perm2.slice(0);
			break;
		case 3:
			permFriends = perm3.slice(0);
			break;
		case 4:
			permFriends = perm4.slice(0);
			break;
		case 5:
			permFriends = perm5.slice(0);
			break;
		default:
			permFriends = null;
	}
}

/* Still to be extended functions. Not to be used yet. */ 
function callback(response) {
	// do something if required.
}

function waitForAsynchronousCalls(flags, len) {
	for(var i = 0; i < len ; i++) {
		if(flags[i] == false)
			return false;
	}
	return true;
}
